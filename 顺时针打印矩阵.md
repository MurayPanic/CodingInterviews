# 剑指offer- 顺时针打印矩阵
题目描述： 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，
例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.

## 解题思路：
- 直接模拟指针的行动
- 将问题转化为一层一层地输出

## 解法一： 直接模拟指针的行动
- 主体循环的次数是矩阵里面元素的个数。
- 需要建立一个同样大小的矩阵，记录该位置的元素是否已经被读取
- 每次移动指针都要判断下一个位置是否下标越界，同时下一个位置是否已经被读取过。
- 如果发现下一个位置为非法位置或者已经被读取过，则指针的方向旋转九十度。
- 指针旋转的操作是通过控制下标的递增情况进行。
- 这里虽然说是指针，但是实际代码中操作的是下标

```c++
class Solution {
public:
    vector<int> printMatrix(vector<vector<int> > matrix) {
         vector<int> result;
       
        int hor_len = (*matrix.begin()).size();
        int ver_len = matrix.size();
        
        vector<vector<bool> > visit(ver_len);
        
        for (auto &row : visit){
            row.resize(hor_len);
            for ( auto col : row  ){
                col = false;
            }
        }
        
        int i{0};
        int j{0};
        int curr_dir{0};
            
        
        for(int move=0; move< hor_len*ver_len; ++move){
            result.push_back(matrix[i][j]);
            visit[i][j]= true;
            vector<int> dir_vec = getDirection(curr_dir);
            int next_i = i+ dir_vec[0];
            int next_j = j+ dir_vec[1];
            
            bool changeDirection =false;
            if (next_i <ver_len && next_i>=0 && next_j<hor_len && next_j>=0){
                
                if( visit[next_i][next_j] ){changeDirection = true;}
                
            }else{
                changeDirection = true;
            }
            
            
            if(changeDirection){
                curr_dir = (curr_dir + 1) % 4;
                dir_vec = getDirection(curr_dir);
                i += dir_vec[0];
                j += dir_vec[1];
               
            }else{
                i = next_i;
                j = next_j;
                
                
                
            }
            
            
        }
        
        
        
        return result;
        
    }
    
    
    vector<int> getDirection(int i){
        vector<int> direction;
        switch(i){
                case(0): 
                    direction.push_back(0);
                    direction.push_back(1);
                    
                case(1):
                    direction.push_back(1);
                    direction.push_back(0);
                    
                case(2):
                     direction.push_back(0);
                     direction.push_back(-1);
                case(3):
                     direction.push_back(-1);
                     direction.push_back(0);
        
        }
        return direction;
    }
    
   
    
};

```

## 解法二： 逐层打印
